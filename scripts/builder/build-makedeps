#!/usr/bin/env build
cat >"${BUILDER_MAKEFILE}" <<EOF
##
# Some generic catchall rules
all: packages_archive
all_fetch: packages_fetch
all_clean: tmpdir_clean sysroot_clean
all_distclean: tmpdir_clean sysroot_clean artifacts_clean tooldir_clean
all_prep: packages_prep
all_compile: packages_compile
all_archive: packages_archive
all_install: packages_install
all_makedeps:

sysroot_clean:
	@if [ -d "${SYSROOT}" ]; then echo cleaning: sysroot;rm -rf "${SYSROOT}";fi
tmpdir_clean:
	@if [ -d "${BUILDER_TMPDIR}" ]; then echo cleaning: tmpdir; (cd "${BUILDER_TMPDIR}" && rm -rf *);fi
tooldir_clean:
	@if [ -d "${TOOLDIR}" ]; then echo cleaning: tooldir;rm -rf "${TOOLDIR}";fi
artifacts_clean:
	@if [ -d "${BUILDER_ATFDIR}" ]; then echo cleaning: artifacts;rm -rf "${BUILDER_ATFDIR}";fi


EOF

PACKAGES=
PACKAGES_SOURCES=
PACKAGES_COMPILE=
PACKAGES_ARCHIVE=
PACKAGES_INSTALL=
PACKAGES_CLEAN=
for package in $(cd "${BUILDER_PKGDIR}" && echo */*); do
	if ! eval $(build query --environ "${package}"); then
		die "in package '${package}'"
	fi

	package_make="$(echo "${package}"|tr '/-' '__')"
	package_archive="${BUILDER_ATFDIR}/${CATEGORY}/${NAME}-${VERSION}.${ARCHIVE_FORMAT}"
	package_install="${W}/.installed"
	package_logdir="${L}"

	package_sources="${RULESFILE}"
	for patch in ${PATCHES}; do
		patch="${F}/${NAME}-${VERSION}-${patch}.patch"
		if [ ! -f "${patch}" ]; then
			die "patch does not exist '${patch}'"
		fi
		package_sources="${package_sources} ${patch}"
	done

	# FIXME there can be strange characters in a URI .. this might not be
	# the best approach in the long term.
	for url in ${SOURCE_URI}; do
		case "${url}" in
		# Do not translate local paths into archives in BUILDER_SRCDIR
		(file://*|/*)	package_sources="${package_sources} ${url##file://}";;

		# Assume anything else with :// in the name is remote
		(*://*)		pkg_src="$(build-fetch --name "${url}")"
				if [ $? -ne 0 ]; then
					exit 1
				fi
				package_sources="${package_sources} ${BUILDER_SRCDIR}/${pkg_src}";;
		# Junk?
		(*)		die "do not know how to handle url '${url}'";;
		esac
	done

	# This loop can end up being fairly costly if we have to fire up
	# build-query, particularly when dealing with a large number of
	# packages.  So we do some FS level checks first in hopes of avoiding
	# it and improving performance.
	package_deps=
	for pkg_dep in ${BDEPENDS}; do
		if [ ! -d "${BUILDER_PKGDIR}/${pkg_dep}" ]; then
			if [ ! -d "${BUILDER_PKGDIR}/${PROJECT_NAME}/${pkg_dep}" ]; then
				if ! build query --exists "${pkg_dep}"; then
					die "bad BDEPENDS in package '${package}'"
				fi
			elif [ ! -f "${BUILDER_PKGDIR}/${PROJECT_NAME}/${pkg_dep}/Buildrules" ]; then
				die "no Buildrules for '${pkg_dep}'"
			fi
			pkg_dep="${PROJECT_NAME}/${pkg_dep}"
		elif [ ! -f "${BUILDER_PKGDIR}/${pkg_dep}/Buildrules" ]; then
			die "no Buildrules for '${pkg_dep}'"
		fi
		package_deps="${package_deps} ${BUILDER_TMPDIR}/${pkg_dep}/build/.installed"
	done

cat <<EOF
##
# ${CATEGORY}/${NAME} - ${DESCRIPTION}
${package_make}: ${package_archive}
${package_make}_fetch: ${package_sources}
${package_make}_prep: ${package_sources}
	@if ! build-prep ${CATEGORY}/${NAME}; then \
		echo "error: failed to prepare package '${CATEGORY}/${NAME}'" >&2 ;\
		echo "logfile: '${L}/prep.log'" >&2 ;\
		exit 1 ;\
	fi
${package_make}_compile: ${package_make}_prep ${package_deps}
	@if ! build-compile ${CATEGORY}/${NAME}; then \
		echo "error: failed to compile package '${CATEGORY}/${NAME}'" >&2 ;\
		echo "logfile: '${L}/compile.log'" >&2 ;\
		exit 1 ;\
	fi
${package_make}_archive: ${package_archive}
${package_archive}: ${package_make}_compile
	@if ! build-archive ${CATEGORY}/${NAME}; then \
		echo "error: failed to archive package '${CATEGORY}/${NAME}'" >&2 ;\
		echo "logfile: '${L}/archive.log'" >&2 ;\
		exit 1 ;\
	fi
${package_make}_install: ${package_install}
${package_install}: ${package_archive}
	@build-install ${CATEGORY}/${NAME}
${package_make}_makedeps:
${package_make}_clean:
	@build-clean ${CATEGORY}/${NAME}
EOF

	##
	# This is a bit of a fun late-injection of the source archive for a
	# package.  The core problem is that multiple packages may depend on
	# the same sources, so we set up a separate rule for the source
	# archive when processing the package, but only if an existing entry
	# for that source does not exist.  We use the source name (as opposed
	# to the package name) to track if the package already has a rule.  The
	# whole thing really translates into something like
	# foo_1_1_3_tar_bz2="http://some/path/to/foo-1.1.3.tar.bz2"
	# All forms of URL translation and variable translation are done for us
	# by fetch so that makedeps doesn't have any specific expectations on
	# what the variable name should be.

	for url in ${SOURCE_URI}; do
		case "${url}" in
		# Do not translate local paths into archives in BUILDER_SRCDIR
		(file://*|/*)	echo "${url##file://}:";;

		# Assume anything else with :// in the name is remote
		(*://*)
			var="$(build-fetch --var "${url}")"
			if [ -z "$(eval echo -n "\$${var}")" ]; then
				eval "${var}='${url}'"
				echo "${BUILDER_SRCDIR}/$(build-fetch --name "${url}"):"
				echo "\t@build-fetch \"${url}\""
			fi
			;;
		esac
	done

	if [ "${CATEGORY}" = "${PROJECT_NAME}" ]; then
		PACKAGES="${PACKAGES} ${package_make}"
		PACKAGES_SOURCES="${PACKAGES_SOURCES} ${package_sources}"
		PACKAGES_COMPILE="${PACKAGES_COMPILE} ${package_make}_compile"
		PACKAGES_ARCHIVE="${PACKAGES_ARCHIVE} ${packages_archive}"
		PACKAGES_INSTALL="${PACKAGES_INSTALL} ${package_install}"
	fi
	PACKAGES_CLEAN="${PACKAGES_CLEAN} ${package_make}_clean"
done >> "${BUILDER_MAKEFILE}"

cat<<EOF >> "${BUILDER_MAKEFILE}"
packages_fetch: ${PACKAGES_SOURCES}
packages_prep: ${PACKAGES_SOURCES}
packages_compile: ${PACKAGES_COMPILE}
packages_archive: ${PACKAGES_ARCHIVE}
packages_install: ${PACKAGES_INSTALL}
packages_clean: ${PACKAGES_CLEAN}
EOF

# vim: filetype=sh
