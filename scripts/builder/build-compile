#!/usr/bin/env build

echo "compiling: ${1}"

pkg_compile()
{
	# FIXME these defaults need moved elsewhere
	if [ -f "configure" ]; then
		./configure	--host="${CHOST}"			\
				--prefix="/usr" --mandir=/usr/share/man	\
				--docdir=/usr/share/doc			\
				--sysconfdir=/etc			\
				${CONFIG_OPTS}
	fi

	# FIXME we need a bunch of make options in here
	make ${MAKE_OPTS} && make DESTDIR="${D}" install
}

# Declare compilation variables before import as the package may potentially
# overwrite this data, in particular the toolchain data is usually rewritten
# within the toolchain/buildtools rule.
eval "$(build-query --toolchain "${CHOST}")"

# pkgconfig can be a right pita...
PKG_CONFIG_LIBDIR="${SYSROOT}/usr/share/pkgconfig:${SYSROOT}/usr/lib/pkgconfig"
export PKG_CONFIG_LIBDIR PKG_CONFIG_PATH
export PKG_CONFIG_SYSROOT_DIR="${SYSROOT}"

# Don't pass along the builder jobcontrol data to child processes
unset MAKEFLAGS

import "${1}"

## Prep the build environment
# Technically much of this should have been done in build-prep, and this sort
# of duplication of work may be useful to make a function within the top-level
# build script.  Perhaps builder_mkenv [prep|compile|archive|etc..]
if [ -d "${D}" ]; then
	mv "${D}" "${D}.old"
	rm -rf "${D}" &
fi
[ -d "${S}" ] || mkdir -p "${S}"
[ -d "${L}" ] || mkdir -p "${L}"
[ -d "${E}" ] || mkdir -p "${E}"
[ -d "${T}" ] || mkdir -p "${T}"
[ -d "${D}" ] || mkdir -p "${D}"

## Prep the logging
cat /dev/null >  "${L}/compile.log"
set > "${E}/compile.env"

## Build the source and install it into the DESTDIR
# Ironically this is the heart of what the build-engine does, and yet it has
# been reduced to the simplest component of the entire system.
cd "${S}"
pkg_compile >> "${L}/compile.log" 2>&1

## Save Space!
# At this point everything important should be installed into ${D}, and any
# form of reruning the build will remove ${S} before prepping it for build, so
# we might as well gut it now.  About the best option we could do would be to
# avoid gutting this when being run in --debug mode.
rm -rf "${S}" &

##
# Generate the file index.  This is done as a 0 delimited file stored within
# the destination filesystem.  This allows for easy checking of the installed
# data as well as easy removal of individual binary packages from the sysroot.
mkdir -p "${D}/var/db/binpkgs/${CATEGORY}"
binpkg_list="$(mktemp "${T}/binpkg.XXXXXXXX")"
if [ ! -e "${binpkg_list}" ]; then
	die "failed to create package inventory"
fi
cd "${D}"
find . -depth -print0 > "${binpkg_list}"
mv "${binpkg_list}" "${D}/var/db/binpkgs/${CATEGORY}/${NAME}"

##
# Technically everything should be done, but our removal of ${D}.old and ${S}
# might still be running, so wait for everything before we exit.
wait

# vim: filetype=sh
